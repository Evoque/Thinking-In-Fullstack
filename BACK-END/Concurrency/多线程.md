

线程池存放任务的队列，这个队列能够根据需要自行调整。



- 并行处理

  > 把正在执行的大量的任务分割成小块，分配给多个同时运行的线程。
  >
  > 并行处理是多线程的一种，而多线程是并发的一种。

- 异步编程

  > 并发的一种形式，采用`future`模式或者`callback`机制， 以避免产生不必要的线程
  >
  > 异步编程的核心理念是异步操作，启动了的操作将会在一段时间后完成。这个操作正在执行时，不会阻塞原来的线程。启动了这个操作的线程，可以继续执行其他任务。
  >
  > 响应式编程时基于`异步事件(asynchronous event)`，而不是异步操作。
  >
  > 要大胆地把各种并发编程形式进行混合和匹配，在程序的各个部分使用合适的工具。



- 异步编程的两大好处

  - 对于面向终端用户的GUI程序：异步编程提高了响应能力。我们在遇到运行时会临时锁定界面的程序，异步编程可以使程序在执行任务时仍能响应用户的输入。

    >  目前Web都是前后端分离的，并没有锁定GUI一说。 `是不是IIS中处理Request请求的线程有限，使用异步可扩展请求线程的响应能力？`

  - 对于服务器端应用：异步编程实现了可扩展性。服务器应用可以利用线程池满足其可扩展性，使用异步编程后，可扩展性通常可以提高一个数量级。

    > 具体的应用实例？



一般来说，运行UI线程时采用UI上下文，处理ASP.NET请求时采用ASP.NET请求上下文，其他很多情况则采用线程池上下文。



关于恢复上下文， 最好的做法是，在核心库代码中一直使用`ConfigureAwait`，在外围的用户界面代码中，只在需要时才恢复上下文。

> 一直没有找到造成线程死锁的具体例子啊



### 创建Task实例的两种方法

1. 有些任务表示CPU需要实际执行的指令，创建这种计算类的任务时，使用`Task.Run`(如需要按照特定的计划运行，则用`Task.Factory.StartNew`, 其相对于`Run`可实现异步操作更细粒度的控制， 具体查看官方文档及`TaskScheduler`)
2. 任务表示一个通知(notification)，创建这种基于事件的任务时，使用`TaskCompletionSource<T>`。 大部分I/O型任务采用`TaskCompletionSource<T>`



### 异常操作

一旦异步方法抛出(或传递出)异常，该异常会放在返回的Task对象中，并且这个Task对象的状态会编程"已完成". await 会获得并(重新)抛出该异常。



异步方法的一条重要的准则：

> 你一旦在代码中使用了异步，最好一直使用！
>
> 一定要避免使用`Task.Wait`或`Task<T>.Result`方法，因为它们会导致死锁. (`为什么会导致死锁？`)

下面是一个死锁的例子:

```c#
void Deadlock()
{
    Task task = WaitAsync();
    
    // 同步程序块，正在等待异步方法完成
    task.Wait();
}

async Task WaitAsync()
{
    // 这里await 会捕获当前上下文
    await Task.Delay(TimeSpan.FromSeconds(1));
    // 这里会试图用上面捕获的上下文继续执行
}
```

如果从`UI`或`ASP.NET`的`上下文`调用这段代码，就会发生死锁。这是因为两种上下文每次只能运行一个线程。`Deadlock`方法(同步)等待`WaitAsync`方法完成，同时阻塞了`上下文线程`。当delay语句结束时，await试图在已捕获的上下文中继续运行WaitAsync方法，但这个步骤无法成功，因为上下文中已经有了一个阻塞线程，并且这种上下文只允许同时运行一个线程。这里有两个方法可以避免死锁：

1. 在WaitAsync中使用`ConfigureAwait(false)`(使await忽略该方法的上下文)
2. 使用await 调用WaitAsync方法(让Deadlock变成一个异步方法).

> 关于第二个解决办法不是很理解。
>
> 如果使用了`async`，最好一直使用它。





### 并行编程简介

如果程序中有大量的计算任务，并且这些任务能分割成几个相互独立的任务块， 那就应该使用并行编程。

但在通常情况下， 在服务器系统上进行并行编程，将降低本身的并行处理能力，并且不会有实际的好处。

在并行处理时有一个非常重要的准则：每个任务块都要尽可能的相互独立。

一旦你在多个线程中共享状态，就必须以同步方式访问这些状态，那样程序的并行性就变差了。



### 响应式编程简介





















































