## 派生项目

> 如果要为一个自己没有推送权限的项目贡献代码，GitHub鼓励使用派生(`fork`)。 到那个感兴趣的项目主页上，点击页面上的`fork`按钮，GitHub就会为你复制一份该项目的副本到你的仓库中，这样你就可以向自己的这个副本推送数据了。

好处：项目拥有者不必忙于应付他人推送权限的工作。事后，只需要项目维护者将这些副本仓库加为远程仓库，然后提取更新合并即可。



> 下面要学习如何利用Git来组织和完成分布式工作流程。
>
> 特别是，当作为项目贡献者时，我们该怎么做才能方便维护者采纳更新(**怎么push**)；或者作为项目维护者时，又该怎样有效管理大量贡献者的提交。

### 分布式工作流程

在Git中，每个开发者同时扮演**节点**和**集线器**的角色。

#### 集中式工作流

目前我们在用的工作流。 使用比较广泛。

#### 集成管理员工作流

由于Git允许使用多个远程仓库，开发者便可以建立自己的公共仓库，往里面写数据并共享给他人，而同时又可以从别人的仓库中提取他们的更新过来。

这种情形一般都会有个代表官方发布的项目仓库(blessed repository)，开发者们由此仓库克隆出自己的公共仓库(developer public)，然后将自己的提交推送上去，请求官方仓库的维护者拉取更新合并到主项目中。维护者在自己的本地也有个克隆仓库(integration manager)，他可以将你的公共仓库作为远程仓库添加进来，经过测试无误后合并到主干分支，然后再推送到官方仓库。

- 贡献者克隆(fork)此仓库，修订或编写新代码；
- 贡献者推送数据到自己的公共仓库developer public；
- 贡献者给维护者发送邮件，其请求拉取自己的最新修订；

这么做的主要**优点**在于：你可以按照自己的节奏继续工作，不必等待维护者处理你提交的更新；而维护者也可以按照自己的节奏，任何时候都可以过来处理接纳你的贡献。



#### 提交说明

一份好的提交指南可以帮助协作者更轻松更有效地配合。

- 将每次提交限定于完成一次逻辑功能；可能的话，适当地分解为多次小更新，以便每次小型提交都更易于理解；这么做也方便自己将来取消某个特定问题的修复。
- 一般来说，提交说明最好限制在一行以内，50个字符一下，简明扼要地描述更新内容，空开一行后，再展开详细注解。



1. `git push myfork featureA`: 把`featureA`分支整个推送到`fork`到仓储上去

2. 然后通知项目管理员，让他来抓取你的代码 — `pull request`. 可以直接用网站提供的`pull request`按钮自动发送请求通知；或者手工`git request-pull`命令输出结果电邮给项目管理员。

   ```shell
                    #本地特性分支开始前的原始分支
   git request-pull origin/master myfork 
   
   ```

像这样随时保持自己的`master`分支和官方`origin/master`同步，并将自己的工作限定在特性分支上的做法，既方便又灵活，采纳和丢弃都轻而易举。



假设项目管理员接纳了许多别人提交的补丁之后，准备要采纳你提交的第一个分支，缺发现因为代码基准不一致，合并工作无法正确干净地完成。这就需要你再次衍合到最新的`origin/master`，解决相关冲突，然后重新提交你的修改:

```powershell
$ git checkout featureA
	$ git rebase origin/master
	$ git push -f myfork featureA
```

注意，此时推送分支必须使用`-f`选项替换远程已有的`featureA`分支，因为新的commit并非原来的后续更新。



在考虑另一种情形：管理员看过第二个分支后觉得思路新颖，但想请你修改具体实现。我们只需以当前`origin/master`分支为基准，开始一个新的特性分支`featureBv2`，然后把原来的`featureB`的更新拿过来，解决冲突，按要求重新实现部分代码，然后将此特性分支推送上去:

```powershell
$ git checkout -b featureBv2 origin/master
	$ git merge --no-commit --squash featureB
	$ ( change implementation )
	$ git commit 
	$ git push myfork featureBv2
```

这里，`--squash`选项将目标分支上的所有更改全拿来应用到当前分支上，而`--no-commit`选项告诉Git此时无需自动生成和记录(合并)提交。 这样，你就可以在原来代码的基础上，继续工作，最后一起提交。















