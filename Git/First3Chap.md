

> 前三章都是特基本的知识点， 合在一起过一遍

## 第一章
- 什么是版本控制？到底有啥用？为什么我要关心它？
> 官方定义： 版本控制(`Version Control System`)是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 
> OK，举个今天实际遇到的例子。 前段时间对一个项目`service`层的重构，自然会影响影响到所有的模块，虽然特别注意的做了测试， 但是一些隐藏比较深的功能点还是没有进行操作，如`弹出Modal -> 操作 -> 再弹出Moda -> 操作+1`, Bingo, 你中奖了。 出现`bug`的时候一脸懵逼，一个`services`层的接口变量为空， 代码已经是n个月之前了，而且`services`层也已经面目全非。 这时候咋整？ 要么你去翻当时的接口文档，重新梳理这部分业务；要么你能还原到当时的代码，如果当时的代码有注意，那还原起来就省事太多了。 这个时候，我打开`gitlab`，定位到目标文件，然后打开这个文件的修改历史， 猜测下大概时间，对相关的`commit`进行检查， 一个文件顶多也就涉及到十几次的`commit`一个一个的看也快。 就这样， 没花十分钟，`bug fixed`。 想象一下， 如果这时候没有`git`的版本回溯查看功能，咋整？

- `VSS + SVN` VS. `Git`
关于**集中化版本控制系统**和**分布式版本控制系统**的优缺点对比，没啥好讲的。 我并不认同`分布式就是好的`,这种观点，哪种用好了都可以。 但是当然要选择优点更多，更潮流的东西不是， 而且现在，啥都往分布式上靠。 

- `Git` 的出生
简单来说就是`Linus`因为一些事不爽，索性Linux社区开发一个满足需求的版本管理工具自己用， 所以定了下面这些目标:
1. 速度
2. 简单的设计
3. 对非线性开发模式的强力支持(允许上千个并行开发的分支). > ps: 所以，别嫌分支多。
4. 有能力高效管理类似Linux内核一样的超大规模项目(速度和数据量)

现在的Git可以中已经很叼了，而且上面的目标也全部都实现，用的越多，你就越感觉牛逼。



- `Git`原理
Git并不保存前后变化的差异数据。 实际上，Git更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹(`hash`)信息并对文件作一快照，然后保存一个指向这次快照的索引。 为提高行呢给你，若文件没有变化，Git不会再次保存，而只对上次保存的快照作一链接。
咋理解？
其实就是，你每次修改的部分Git会保存起来，而没修改的部分，Git直接引用前一个版本的相关部分，有点类似于`Immutable`的概念， 只更新变化了的地方。


- 本地OK
因为Git是分布式的， 所以不联网，本地执行完全ok。也就是说，你本地存着以前所有的版本历史。 
而且也不会影响你`commit`, 因为`commit`操作的都是本地分支。


- 保持数据完整性
Git的设计哲学是：在保存到Git之前，所有的数据都要进行内容的校验和(checksum)计算(`ps, hash?`)， 病将此结果作为数据的唯一标识和索引。这种机制建立在Git整体架构的最底层。 所以如果文件在传输过程中变得不完整，或者磁盘损坏导致文件数据缺失，Git都能立即察觉。
Git使用`SHA-1`苏啊放哪计算数据的校验和，40个十六进制(`0-9 & a-f`)组成。 一般只看前八位就能唯一确定一个文件了。

这个哈希值贯穿了整个Git的工作流程。 所以在Git中，啥也不信， 就信这个哈希串，错不了。

- 大部分仅添加
为了回退或重现版本方便，Git操作的大多是`添加`操作。 第九章会介绍如何保存和恢复数据的。

- 文件的四种状态

`working directory` ->add-> `staging area` ->commit-> `git directory(repository)` ->pull-> `remote repository`
 
当然这集中状态也是可逆的。
对应流程如下:
1. 在工作目录中修改某些文件
2. 对修改后的文件进行快照，然后保存到暂存区域
3. 提交更新，将保存在暂存区域的文件快照永久转储到Git目录中。 
也就是说， 如果你不`commit`，你的东西还是有丢的可能性。 只要`commit`了，都能找回来。 

